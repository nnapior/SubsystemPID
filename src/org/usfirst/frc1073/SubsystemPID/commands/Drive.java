// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1073.SubsystemPID.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1073.SubsystemPID.Robot;

/**
 * The drive class: Generates setpoints for each mecanum wheel PIDThread (Or the direct to voltage drive values).
 * Process is as follows:
 * - gets joystick values (in polar coordinates)
 * - adds deadzone control and scales joystick values (relative scale)
 * - Perform trig deflections for mecanum wheels 
 * - normalizes drive values for out of bounds control (allows full joystick range control)
 * - if PID is enabled, these generated values are set as the PID setpoints. 
 * - if PID is disabled, then they are sent directly to the drivetrain.
 */
public class  Drive extends Command implements PIDCommand{
	
	private double deadZone;
	private double setpointFL;
	private double setpointFR;
	private double setpointBL;
	private double setpointBR;
	
	//scaler compensates for trig magnitude reduction
	final double scaler = 1 / .707;
	
	private boolean isPID;
	
    public Drive() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
        deadZone = 0.05;
        
        //this needs to be true from the start!
        isPID = true;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	
    	//get the joystick values for mecanum drive
    	double twist = Robot.oi.getdriver().getTwist();
		double mag = Robot.oi.getdriver().getMagnitude();
		double joyAngle = Robot.oi.getdriver().getDirectionDegrees();
		double joyScale = Robot.oi.getdriver().getZ();
		
		//deadzone adjust
		if (Math.abs(mag) < deadZone) {
			mag = 0;
		}
		if (Math.abs(twist) < deadZone) {
			twist = 0;
		}
		
		joyScale = ((joyScale * -1) + 1) / 2;
		
		if(Math.abs(joyScale) < .1){
			joyScale = 0;
		}
		
		//printouts for the joystick scale and PID status
		SmartDashboard.putNumber("Joystick Scale: ", joyScale);
		SmartDashboard.putBoolean("is PID Enabled? :", isPID);
		
		//mag and twist scaling
		mag = mag * joyScale;
		twist = twist * joyScale;
		
		//mecanum joystick deflection
		joyAngle = ((joyAngle + 45) * 3.14159) / 180;
		double sinAngle = Math.sin(joyAngle);
		double cosAngle = Math.cos(joyAngle);
		
		//mecanum wheel deflection (creates PID setpoints)
		double drivePointFL = (sinAngle * mag + twist) * scaler;
		double drivePointFR = (cosAngle * mag - twist) * scaler;
		double drivePointBL = (cosAngle * mag + twist) * scaler;
		double drivePointBR = (sinAngle * mag - twist) * scaler;
		
		//normalize output (prevents > 1.0 setpoints)
		double[] drivePoints = normalize(drivePointFL, drivePointFR, drivePointBL, drivePointBR);
		
		//move back to setpoint variables from array
		drivePointFL = -1 * drivePoints[0];
		drivePointFR = drivePoints[1];
		drivePointBL = -1 * drivePoints[2];
		drivePointBR = drivePoints[3];
		
		//if PID is enabled, enable PID in the two subsystems and assign setpoints
		if(isPID){
			Robot.driveTrain.enablePIDDrivetrainParameter();
			Robot.encoderSystem.enablePIDEncoderParameter();
			
			setpointFL = drivePointFL;
			setpointFR = drivePointFR;
			setpointBL = drivePointBL;
			setpointBR = drivePointBR;
		}
		//if PID is disabled, disable PID in the subsystems. Then, pass the mecanum deflections directly to the drivetrain. 
		//set the setpoints to 0 to prevent issues with PIDThreads continuing to perform PID calculations. 
		else{
			Robot.driveTrain.disablePIDDrivetrainParameter();
			Robot.encoderSystem.disablePIDEncoderParameter();
			
			Robot.driveTrain.setFrontLeftSpeed(drivePointFL);
			Robot.driveTrain.setFrontRightSpeed(drivePointFR);
			Robot.driveTrain.setBackLeftSpeed(drivePointBL);
			Robot.driveTrain.setBackRightSpeed(drivePointBR);
			
			setpointFL = 0;
			setpointFR = 0;
			setpointBL = 0;
			setpointBR = 0;
		}
		
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
    
    /**
     * Normalizes the drive values for the mecanum drive. allows for full joystick range. 
     * @param FL
     * @param FR
     * @param BL
     * @param BR
     * @return
     */
    private double[] normalize(double FL, double FR, double BL, double BR) {
		double[] setpoints = { FL, FR, BL, BR };
		double max = Math.abs(setpoints[0]);
		for (int i = 1; i < 4; i++) {
			double speed = Math.abs(setpoints[i]);
			if (speed > max) {
				max = speed;
			}
		}
		if (max > 1.0) {
			for (int i = 0; i < 4; i++) {
				setpoints[i] = (setpoints[i] / max);
			}
		}
		return setpoints;
	}
    
    /**
     * gets the setpoints for use with the PIDThreads
     */
	@Override
	public double getPIDSetpoint(int marker) {
		switch (marker){
		case 0:
			return setpointFL;
		case 1:
			return setpointFR;
		case 2:
			return setpointBL;
		case 3:
			return setpointBR;
		default:
			return 0;
		}
	}
	
	public void switchDriveMode(){
		isPID = !isPID;
	}

	@Override
	public boolean isPIDEnabled() {
		return isPID;
	}
	
}
